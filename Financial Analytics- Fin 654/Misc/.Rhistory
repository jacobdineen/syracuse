cash <- 150 #set random cash variable
NI <- ebit+tax+depreciation #calculate current year net income
total.assets <- cash+nfa #calculate total assets
equity <- NPV.1 (wacc,tcf) + -60 + 150  # #fixed equity
shares.outstanding <- 30 #set shares outstanding variable
share.price <- equity / shares.outstanding #calculate share price
table.names.2 <- c("Debt", "Cash", "Total Assets",
"Equity", "Shares Outstanding", "Share Price")
table.year2 <- year # Assign projection years
table.data.2 <- rbind(debt, cash, total.assets,equity,shares.outstanding, share.price)
(table.data.3 <- round(table.data.2[,4],2))
# 2.8.4 Set B:
x.data <- read.csv("data/hospitals.csv") #Read in data
x.data <- na.omit(x.data)
str(x.data) #call data structure
pairs.panels(x.data) #psych package
#Strong collinearity/correlation between Expenses/Payroll/FTE
#hospital is just an index, so no relationships present. May remove so as not to confuse model with diverse ranges/variance.
#Strong relationship between beds and admissions, beds and expenses/payroll/fte (if relationship with expenses, expected relationship w/ payroll/fte)
cor(x.data) #call just correlation table
corrplot(cor(x.data), method= "square", title="Hospital Correlation")
#Investigate the influence of admission and outpatient rates on expenses and payroll
df <-  subset(x.data, select = c(admissions, outpatients, expense, payroll)) #remove superfluous columns
#Regression Using LM
model.expense <- lm(formula=expense~ admissions+outpatients, data = df)
model.payroll <- lm(formula=payroll~ admissions+outpatients, data = df)
summary(model.expense) #adjusted r2 = .8243
print(model.expense$coefficients) #variables both statistically significant
summary(model.payroll) #adjusted r2 =.7376
print(model.payroll$coefficients)#variables both statistically significant
#Variance in expenses are more tied with variance in  admissions and outpatients than payroll w/ admissions and outpatients
#Use this code to investigate further the relationship among predicted expenses and the drivers, admissions and outpatients.
require(reshape2)
require(ggplot2)
## REGRESSION USING β̂
x.1 <- df$admissions #Store admissions vector
x.2 <- df$outpatients #Store outpatients vector
hist(x.1) #hist admissions
hist(x.2) #hist outpatients
X <- cbind(1, x.1, x.2) #merge two predictors together
y <- df$expense
hist(y)
XTX.inverse <-  solve(t(X) %*% X) #Find inverse of x variable (transposed X * X, sumproduct)
beta.hat <-  XTX.inverse %*% t(X) %*% y #Inverse times transposed X * Y (Finding Coefficents)
actual <- y #Store actual results
predicted <- X %*% beta.hat #Store model predictions
residual <- actual - predicted #Find residuals
results <- data.frame(actual = actual,
predicted = predicted, residual = residual) #Create dataframe
#calculating error
e <- y - X %*% beta.hat	#Another way of calculating residual
(e.sse <- t(e) %*% e)	#Find  estimated sum of squared error
(n <- dim(X)[1])
(k <- nrow(beta.hat))	#degrees of freedom
(e.se <- (e.sse / (n - k))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
min_xy <- min(min(results$actual), min(results$predicted)) #finding min. value in df
max_xy <- max(max(results$actual), max(results$predicted)) #finding max. value in df
plot.melt <- melt(results, id.vars = "predicted") #melting variables into singular column
plot.data <- rbind(plot.melt, data.frame(predicted = c(min_xy,
max_xy), variable = c("actual", "actual"),
value = c(max_xy, min_xy))) #combining dataframes
#Plotting data frame
p <- ggplot(plot.data, aes(x = predicted,
y = value)) + geom_point(size = 2.5) +   theme_bw()
p <- p + facet_wrap(~variable, scales = "free")
p
#PRO1 PART 2 Challenge 1
# Change one of the dependent variables
##Changing Outpatients to 'Beds'
ch1 <-  subset(x.data, select = c(admissions, beds, expense)) #remove superfluous columns
model.expense.2 <- lm(formula = expense~. , ch1)
summary(model.expense.2) #adjusted r^2 = .85
print(model.expense.2$coefficients)
x.1.1 <- ch1$admissions
x.2.1 <- ch1$beds
X1 <- cbind(1,x.1.1,x.2.1)
y1 <- ch1$expense
XTX.inverse.1 <-  solve(t(X1) %*% X1) #Find inverse of x variable (transposed X * X, sumproduct)
beta.hat.1 <-  XTX.inverse.1 %*% t(X1) %*% y1 #Inverse times transposed X * Y (Finding Coefficents)
actual.1 <- y1 #Store actual results
predicted.1 <- X1 %*% beta.hat.1 #Store model predictions
residual.1 <- actual.1 - predicted.1 #Find residuals
results.1 <- data.frame(actual = actual.1,
predicted = predicted.1, residual = residual.1) #Create dataframe
#calculating error
e.1 <- y1 - X1 %*% beta.hat.1	#Another way of calculating residual
(e.sse.1 <- t(e.1) %*% e.1)	#Find  estimated sum of squared error
(n.1 <- dim(X1)[1])
(k.1 <- nrow(beta.hat.1))	#degrees of freedom
(e.se.1 <- (e.sse.1 / (n.1 - k.1))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
# PRO1 PART 2 CHALLENGE 2
# Choose three dependent variables
ch2 <-  subset(x.data, select = c(admissions,outpatients, beds, expense)) #remove superfluous columns
# REGRESSION USING lm()
model.expense.3 <- lm(formula= expense~., ch2)
summary(model.expense.3) #all variables stat. significant (pvalue <.05)
# REGRESSION USING β̂
x.1.2 <- ch2$admissions
x.2.2 <- ch2$outpatients
x.3.3 <- ch2$beds
X2 <- cbind(1,x.1.2,x.2.2,x.3.3)
y2 <- ch2$expense
XTX.inverse.2 <-  solve(t(X2) %*% X2)
beta.hat.2 <- XTX.inverse.2 %*% t(X2) %*% y2
actual.2 <- y2
predicted.2 <- X2 %*% beta.hat.2
residual.2 <- actual.2 - predicted.2
results.2 <- data.frame(actual = actual.2, predicted = predicted.2, residual= residual.2)
#calculating error
e.2 <- y2 - X2 %*% beta.hat.2	#Another way of calculating residual
(e.sse.2 <- t(e.2) %*% e.2)	#Find  estimated sum of squared error
(n.2 <- dim(X2)[1])
(k.2 <- nrow(beta.hat.2))	#degrees of freedom
(e.se.2 <- (e.sse.2 / (n.2 - k.2))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
y
## REGRESSION USING β̂
x.1 <- df$admissions #Store admissions vector
x.2 <- df$outpatients #Store outpatients vector
hist(x.1) #hist admissions
hist(x.2) #hist outpatients
X <- cbind(1, x.1, x.2) #merge two predictors together
y <- df$expense
hist(y)
XTX.inverse <-  solve(t(X) %*% X) #Find inverse of x variable (transposed X * X, sumproduct)
beta.hat <-  XTX.inverse %*% t(X) %*% y #Inverse times transposed X * Y (Finding Coefficents)
actual <- y #Store actual results
predicted <- X %*% beta.hat #Store model predictions
residual <- actual - predicted #Find residuals
results <- data.frame(actual = actual,
predicted = predicted, residual = residual) #Create dataframe
results
#PRO1 PART 1 Q1 Challenge 2
debt <- -60 #set random debt variable
cash <- 150 #set random cash variable
NI <- ebit+tax+depreciation #calculate current year net income
total.assets <- cash+nfa #calculate total assets
equity <- NPV.1 (wacc,tcf) + -60 + 150  # #fixed equity
shares.outstanding <- 30 #set shares outstanding variable
share.price <- equity / shares.outstanding #calculate share price
table.names.2 <- c("Debt", "Cash", "Total Assets",
"Equity", "Shares Outstanding", "Share Price")
table.year2 <- year # Assign projection years
table.data.2 <- rbind(debt, cash, total.assets,equity,shares.outstanding, share.price)
(table.data.3 <- round(table.data.2[,4],2))
equity <- NPV.1 (wacc,tcf) + debt + cash  # #fixed equity
equity
#Jacob Dineen, Stephanie Salvatore, Diana Couillard
#Financial Analytics
#1/13/2018a
#CLEAR ENVIRONMENT AND INSTALL INITIAL PACKAGES
rm(list = ls(all = TRUE))#Clear Enviroment
#use this function to check if each package is on the local machine if a package is installed, it will be loaded if any are not, the missing package(s) will be installed and loaded
packages <- c("ggplot2", "psych", "corrplot")
package.check <- lapply(packages, FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x, dependencies = TRUE)
library(x, character.only = TRUE)
}
})
#2.8.3 Set A
wacc <-	0.18 #average weighted cost of capital
sales0 <-	80 #sales in year 1
growth1 <-	0.5 #growth from next 3 years
growth4 <-	0.15 #growth from years 4 on
cost.sales <-	0.75 #project to be a flat cost of 75%
depreciation.nfa <-	0.05 #constant 5% depreciation (of NFA)
tax.rate <-	0.35 #tax rate
wc.incr.sales <-	0.1 #increase in working capital at the rate of 15% each year
nfa.incr.sales <-	0.05 #increase in fixed assets at the rate of 10% of sales each year
wc0 <-	10 #year 1 working capital
dep.accum <-	15 #year 1 depreciation
nfa0 <-	90 #year 1 netfixedassets
time <-	1:4 #seq array of projected years
growth <-	rep(0.5, 4) #array of growth pattern projections
growth[4] <-	growth4 #replacing year four growth with 0.15 projected growth
sales <-	sales0 * (1 + growth) ^ time #initial sales * 1.xx growth rate raised to the year
sales[4] <-	sales[3] * (1 + growth[4]) #replacing sales value 4 to account for 15% projected growth
nfa.incr <-	nfa.incr.sales * sales #0.05 nfa incr. X sales
nfa <-	cumsum(c(nfa0, nfa.incr))[-1] #cumulative sums of starting nfa with projections layered on
year0 <-	2016 #default/starting year
year <-	year0 + time #seq year for projections
sales	# computed above
cost <-	cost.sales * sales #75% of sales
gp <-	sales - cost #gross profit calc
sga <-	rep(0,4) #null values X 4
depreciation <-	depreciation.nfa * nfa #projects netfixedassets * .05 flat deprec.
ebit <-	gp - sga - depreciation #gross profit - selling,gen.,admin - depreciation
tax <-	ebit * tax.rate #Ebit * Tax rate (35%)
depreciation	# computed above
nfa.incr	# computed above
wc.incr <-	wc.incr.sales * sales
fcf <-	ebit - tax + depreciation -nfa.incr -wc.incr #Free Cash Flow projections
# Form table of results
table.names <- c("Sales", "Cost", "Working Capital (incr.)",
"Net Fixed Assets (incr.)", "Free Cash Flow")
# Assign projection labels
table.year <- year # Assign projection years
table.data <- rbind(sales, cost, wc.incr,
nfa.incr, fcf)  # Layer projections
rownames(table.data) <- table.names  # Replace rows with projection labels
colnames(table.data) <- table.year  # Replace columns with projection years
knitr::kable(round(table.data,2))  # Display a readable table
#PRO1 PART 1 Q1 Challenge 1
fcfafter4 <-  fcf[4] * (1+growth4) #freecash flow after year 4
terminal.value.4 <-  fcfafter4/(wacc-growth4) # last fcf / (wacc - growth4)
terminal.value <-  round(c(0,0,0, terminal.value.4),2)
tcf <- round(terminal.value + fcf[1:4],2) # earlier years tcf is same as fcf
#Function for NPV
NPV.1 <-  function(rates, cashflows) {
NPV <-  sum(tcf/(1+rates)^(seq_along(tcf)))
return(NPV)
}
rates <- rep(wacc, 4)
cashflows <-  tcf
NPV.1 (wacc,tcf)
#PRO1 PART 1 Q1 Challenge 2
debt <- -60 #set random debt variable
cash <- 150 #set random cash variable
NI <- ebit+tax+depreciation #calculate current year net income
total.assets <- cash+nfa #calculate total assets
equity <- NPV.1 (wacc,tcf) + debt + cash  # #fixed equity
shares.outstanding <- 30 #set shares outstanding variable
share.price <- equity / shares.outstanding #calculate share price
table.names.2 <- c("Debt", "Cash", "Total Assets",
"Equity", "Shares Outstanding", "Share Price")
table.year2 <- year # Assign projection years
table.data.2 <- rbind(debt, cash, total.assets,equity,shares.outstanding, share.price)
(table.data.3 <- round(table.data.2[,4],2))
# 2.8.4 Set B:
x.data <- read.csv("data/hospitals.csv") #Read in data
x.data <- na.omit(x.data)
str(x.data) #call data structure
pairs.panels(x.data) #psych package
#Strong collinearity/correlation between Expenses/Payroll/FTE
#hospital is just an index, so no relationships present. May remove so as not to confuse model with diverse ranges/variance.
#Strong relationship between beds and admissions, beds and expenses/payroll/fte (if relationship with expenses, expected relationship w/ payroll/fte)
cor(x.data) #call just correlation table
corrplot(cor(x.data), method= "square", title="Hospital Correlation")
#Investigate the influence of admission and outpatient rates on expenses and payroll
df <-  subset(x.data, select = c(admissions, outpatients, expense, payroll)) #remove superfluous columns
#Regression Using LM
model.expense <- lm(formula=expense~ admissions+outpatients, data = df)
model.payroll <- lm(formula=payroll~ admissions+outpatients, data = df)
summary(model.expense) #adjusted r2 = .8243
print(model.expense$coefficients) #variables both statistically significant
summary(model.payroll) #adjusted r2 =.7376
print(model.payroll$coefficients)#variables both statistically significant
#Variance in expenses are more tied with variance in  admissions and outpatients than payroll w/ admissions and outpatients
#Use this code to investigate further the relationship among predicted expenses and the drivers, admissions and outpatients.
require(reshape2)
require(ggplot2)
## REGRESSION USING β̂
x.1 <- df$admissions #Store admissions vector
x.2 <- df$outpatients #Store outpatients vector
hist(x.1) #hist admissions
hist(x.2) #hist outpatients
X <- cbind(1, x.1, x.2) #merge two predictors together
y <- df$expense
hist(y)
XTX.inverse <-  solve(t(X) %*% X) #Find inverse of x variable (transposed X * X, sumproduct)
beta.hat <-  XTX.inverse %*% t(X) %*% y #Inverse times transposed X * Y (Finding Coefficents)
actual <- y #Store actual results
predicted <- X %*% beta.hat #Store model predictions
residual <- actual - predicted #Find residuals
results <- data.frame(actual = actual,
predicted = predicted, residual = residual) #Create dataframe
#calculating error
e <- y - X %*% beta.hat	#Another way of calculating residual
(e.sse <- t(e) %*% e)	#Find  estimated sum of squared error
(n <- dim(X)[1])
(k <- nrow(beta.hat))	#degrees of freedom
(e.se <- (e.sse / (n - k))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
min_xy <- min(min(results$actual), min(results$predicted)) #finding min. value in df
max_xy <- max(max(results$actual), max(results$predicted)) #finding max. value in df
plot.melt <- melt(results, id.vars = "predicted") #melting variables into singular column
plot.data <- rbind(plot.melt, data.frame(predicted = c(min_xy,
max_xy), variable = c("actual", "actual"),
value = c(max_xy, min_xy))) #combining dataframes
#Plotting data frame
p <- ggplot(plot.data, aes(x = predicted,
y = value)) + geom_point(size = 2.5) +   theme_bw()
p <- p + facet_wrap(~variable, scales = "free")
p
#PRO1 PART 2 Challenge 1
# Change one of the dependent variables
##Changing Outpatients to 'Beds'
ch1 <-  subset(x.data, select = c(admissions, beds, expense)) #remove superfluous columns
model.expense.2 <- lm(formula = expense~. , ch1)
summary(model.expense.2) #adjusted r^2 = .85
print(model.expense.2$coefficients)
x.1.1 <- ch1$admissions
x.2.1 <- ch1$beds
X1 <- cbind(1,x.1.1,x.2.1)
y1 <- ch1$expense
XTX.inverse.1 <-  solve(t(X1) %*% X1) #Find inverse of x variable (transposed X * X, sumproduct)
beta.hat.1 <-  XTX.inverse.1 %*% t(X1) %*% y1 #Inverse times transposed X * Y (Finding Coefficents)
actual.1 <- y1 #Store actual results
predicted.1 <- X1 %*% beta.hat.1 #Store model predictions
residual.1 <- actual.1 - predicted.1 #Find residuals
results.1 <- data.frame(actual = actual.1,
predicted = predicted.1, residual = residual.1) #Create dataframe
#calculating error
e.1 <- y1 - X1 %*% beta.hat.1	#Another way of calculating residual
(e.sse.1 <- t(e.1) %*% e.1)	#Find  estimated sum of squared error
(n.1 <- dim(X1)[1])
(k.1 <- nrow(beta.hat.1))	#degrees of freedom
(e.se.1 <- (e.sse.1 / (n.1 - k.1))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
# PRO1 PART 2 CHALLENGE 2
# Choose three dependent variables
ch2 <-  subset(x.data, select = c(admissions,outpatients, beds, expense)) #remove superfluous columns
# REGRESSION USING lm()
model.expense.3 <- lm(formula= expense~., ch2)
summary(model.expense.3) #all variables stat. significant (pvalue <.05)
# REGRESSION USING β̂
x.1.2 <- ch2$admissions
x.2.2 <- ch2$outpatients
x.3.3 <- ch2$beds
X2 <- cbind(1,x.1.2,x.2.2,x.3.3)
y2 <- ch2$expense
XTX.inverse.2 <-  solve(t(X2) %*% X2)
beta.hat.2 <- XTX.inverse.2 %*% t(X2) %*% y2
actual.2 <- y2
predicted.2 <- X2 %*% beta.hat.2
residual.2 <- actual.2 - predicted.2
results.2 <- data.frame(actual = actual.2, predicted = predicted.2, residual= residual.2)
#calculating error
e.2 <- y2 - X2 %*% beta.hat.2	#Another way of calculating residual
(e.sse.2 <- t(e.2) %*% e.2)	#Find  estimated sum of squared error
(n.2 <- dim(X2)[1])
(k.2 <- nrow(beta.hat.2))	#degrees of freedom
(e.se.2 <- (e.sse.2 / (n.2 - k.2))^0.5)	#find estimated square error (raised to .5 is same as sq.root)
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=36))
knitr::opts_chunk$set(size = "small")
knitr::opts_hooks$set(fig.width = function(options) {
if (options$fig.width < options$fig.height) {
options$fig.width = options$fig.height
}
options
})
knitr::knit_hooks$set(mysize = function(before, options, envir) {
if (before)
return(options$size)
})
str(OIL_Brent)
data('OIL_Brent')
str('OIL_Brent')
OIL_Brent
#Week 3 Asynch
library(fBasics)
library(evir)
library(qrmdata)
library(zoo)
data(OIL_Brent)
str(OIL_Brent)
Brent.price <- as.zoo(OIL_Brent)
Brent.return <- diff(log(Brent.price))[-1] * 100
colnames(Brent.return) <- "Brent.return"
head(Brent.return, n = 5)
tail(Brent.return, n = 5)
plot(Brent.return, title = FALSE, xlab = "", main = "Brent Daily % Change", col = "blue")
boxplot(as.vector(Brent.return), title = FALSE, main = "Brent Daily % Change", col = "blue", cex = 0.5, pch = 19)
skewness(Brent.return)
kurtosis(Brent.return)
plot(Brent.return, title = FALSE, xlab = "", main = "Brent Daily % Change", col = "blue")
acf(coredata(Brent.return), main = "Brent Daily Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
pacf(coredata(Brent.return), main = "Brent Daily Partial Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
plot(Brent.return,  xlab = "", main = "Brent Daily % Change", col = "blue")
boxplot(as.vector(Brent.return), title = FALSE, main = "Brent Daily % Change", col = "blue", cex = 0.5, pch = 19)
skewness(Brent.return)
kurtosis(Brent.return)
acf(coredata(Brent.return), main = "Brent Daily Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
pacf(coredata(Brent.return), main = "Brent Daily Partial Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
plot(Brent.return,  xlab = "", main = "Brent Daily % Change", col = "blue")
boxplot(as.vector(Brent.return), title = FALSE, main = "Brent Daily % Change", col = "blue", cex = 0.5, pch = 19)
skewness(Brent.return)
kurtosis(Brent.return)
plot(Brent.return,  xlab = "", main = "Brent Daily % Change", col = "blue")
acf(coredata(Brent.return), main = "Brent Daily Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
pacf(coredata(Brent.return), main = "Brent Daily Partial Autocorrelogram", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
boxplot(as.vector(Brent.return), title = FALSE, main = "Brent Daily % Change", col = "blue", cex = 0.5, pch = 19)
# Trading position size matters
Brent.return.tail <- tail(Brent.return.abs[order(Brent.return.abs)], 100)[1]
# Take just the first of the 100 observations and pick the first
index <- which(Brent.return.abs > Brent.return.tail, arr.ind = TRUE)
Brent.return.abs <-  abs(Brent.return)
# Trading position size matters
Brent.return.tail <- tail(Brent.return.abs[order(Brent.return.abs)], 100)[1]
# Take just the first of the 100 observations and pick the first
index <- which(Brent.return.abs > Brent.return.tail, arr.ind = TRUE)
# Build an index of those sizes that exceed the heavy tail threshold
Brent.return.abs.tail <- timeSeries(rep(0, length(Brent.return)), charvec = time(Brent.return))
# just a lot of zeros we will fill up next
Brent.return.abs.tail[index, 1] <- Brent.return.abs[index]
# A Phew! is in order
plot(Brent.return.abs, xlab = "", main = "Brent Daily Return Sizes", col = "blue")
acf(coredata(Brent.return.abs), main = "Brent Autocorrelogram", lag.max = 60, ylab = "", xlab = "", col = "blue", ci.col = "red")
pacf(coredata(Brent.return.abs), main = "Brent Partial Autocorrelogram", lag.max = 60, ylab = "", xlab = "", col = "blue", ci.col = "red")
require(zoo)
require(qrmdata)
require(xts)
data("EuStockMarkets")
EuStockMarkets.price <- as.zoo(EuStockMarkets)
EuStockMarkets.return <- diff(log(EuStockMarkets.price))[-1] * 100
EuStockMarkets.return
plot(EuStockMarkets.price, xlab = " ", main = " ")
plot(EuStockMarkets.price, xlab = " ", main = " ")
plot(EuStockMarkets.return, xlab = " ", main = " ")
ccf(EuStockMarkets.return[, 1], EuStockMarkets.return[, 2], main = "Returns DAX vs. CAC", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
ccf(abs(EuStockMarkets.return[, 1]), abs(EuStockMarkets.return[, 2]), main = "Absolute Returns DAX vs. CAC", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
ccf(EuStockMarkets.return[, 1], EuStockMarkets.return[, 2], main = "Returns DAX vs. CAC", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
ccf(abs(EuStockMarkets.return[, 1]), abs(EuStockMarkets.return[, 2]), main = "Absolute Returns DAX vs. CAC", lag.max = 20, ylab = "", xlab = "", col = "blue", ci.col = "red")
corr.rolling <- function(x) {
dim <- ncol(x)
corr.r <- cor(x)[lower.tri(diag(dim), diag = FALSE)]
return(corr.r)
}
corr.returns <- rollapply(EuStockMarkets.return, width = 250, corr.rolling, align = "right", by.column = FALSE)
colnames(corr.returns) <- c("DAX & CAC", "DAX & SMI", "DAX & FTSE", "CAC & SMI", "CAC & FTSE", "SMI & FTSE" )
plot(corr.returns, xlab = "", main = "")
fisher <- function(r)
{0.5 * log((1 + r)/(1 - r))}
corr.returns <- rollapply(EuStockMarkets.return, width = 250, corr.rolling, align = "right", by.column = FALSE)
colnames(corr.returns) <- c("DAX & CAC", "DAX & SMI", "DAX & FTSE", "CAC & SMI", "CAC & FTSE", "SMI & FTSE" )
plot(corr.returns, xlab = "", main = "")
require(xts)
require(qrmdata)
require(quantreg)
require(quantmod)
require(matrixStats)
tickers <- c("ELE.MC", "IBE.MC", "REP.MC")
getSymbols(tickers)
plot(ALL.r)
REP.r <- na.omit(diff(log(REP.MC[, 4]))[-1]) # clean out missing values
IBE.r <- na.omit(diff(log(IBE.MC[, 4]))[-1])
ELE.r <- na.omit(diff(log(ELE.MC[, 4]))[-1])
ALL.r <- merge(REP = REP.r, IBE = IBE.r, ELE = ELE.r, all = FALSE)
plot(ALL.r)
par(mfrow = c(2,1))
acf(ALL.r)
R.corr <- apply.monthly(ALL.r, FUN = cor)
R.vols <- apply.monthly(ALL.r, FUN = colSds) # from MatrixStats
head(R.corr, 3)
head(R.vols, 3)
R.corr <- R.corr[, c(2, 3, 6)]
colnames(R.corr) <- c("ELE.IBE", "ELE.REP", "IBE.REP")
colnames(R.vols) <- c("ELE.vols", "IBE.vols", "REP.vols")
head(R.corr, 3)
head(R.vols, 3)
R.corr.vols <- na.omit(merge(R.corr, R.vols))
plot.zoo(merge(R.corr.vols))
R.corr <- R.corr[, c(2, 3, 6)]
colnames(R.corr) <- c("ELE.IBE", "ELE.REP", "IBE.REP")
colnames(R.vols) <- c("ELE.vols", "IBE.vols", "REP.vols")
head(R.corr, 3)
head(R.vols, 3)
R.corr.vols <- na.omit(merge(R.corr, R.vols))
plot.zoo(merge(R.corr.vols))
ELE.vols <- as.numeric(R.corr.vols[,"ELE.vols"])
IBE.vols <- as.numeric(R.vols[,"IBE.vols"])
REP.vols <- as.numeric(R.vols[,"REP.vols"])
length(ELE.vols)
rho_vol <- matrix(as.numeric(R.corr.vols[,1:3]), nrow = length(ELE.vols), ncol = 3, byrow= FALSE)
colnames(R.corr) <- c("ELE.IBE", "ELE.REP", "IBE.REP")
colnames(R.vols) <- c("ELE.vols", "IBE.vols", "REP.vols")
head(R.corr, 3)
head(R.vols, 3)
R.corr.vols <- na.omit(merge(R.corr, R.vols))
plot.zoo(merge(R.corr.vols))
plot(merge(R.corr.vols))
plot.zoo(merge(R.corr.vols))
ALL.r <- merge(REP = REP.r, IBE = IBE.r, ELE = ELE.r, all = FALSE)
plot(ALL.r)
par(mfrow = c(2,1))
par(mfrow = c(2,1))
ALL.r <- merge(REP = REP.r, IBE = IBE.r, ELE = ELE.r, all = FALSE)
plot(ALL.r)
par(mfrow = c(2,1))
acf(ALL.r)
R.corr <- apply.monthly(ALL.r, FUN = cor)
R.vols <- apply.monthly(ALL.r, FUN = colSds) # from MatrixStats
head(R.corr, 3)
head(R.vols, 3)
R.corr <- R.corr[, c(2, 3, 6)]
colnames(R.corr) <- c("ELE.IBE", "ELE.REP", "IBE.REP")
colnames(R.vols) <- c("ELE.vols", "IBE.vols", "REP.vols")
head(R.corr, 3)
plot(ALL.r)
tickers <- c("ELE.MC", "IBE.MC", "REP.MC")
getSymbols(tickers)
REP.r <- na.omit(diff(log(REP.MC[, 4]))[-1]) # clean out missing values
IBE.r <- na.omit(diff(log(IBE.MC[, 4]))[-1])
ELE.r <- na.omit(diff(log(ELE.MC[, 4]))[-1])
ALL.r <- merge(REP = REP.r, IBE = IBE.r, ELE = ELE.r, all = FALSE)
plot(ALL.r)
tickers <- c("ELE.MC", "IBE.MC", "REP.MC")
REP.r <- na.omit(diff(log(REP.MC[, 4]))[-1]) # clean out missing values
IBE.r <- na.omit(diff(log(IBE.MC[, 4]))[-1])
ELE.r <- na.omit(diff(log(ELE.MC[, 4]))[-1])
ALL.r <- merge(REP = REP.r, IBE = IBE.r, ELE = ELE.r, all = FALSE)
plot(ALL.r)
plot(ALL.r)
par(mfrow = c(2,1))
acf(ALL.r)
acf(coredata(Brent.return.abs), main = "Brent Autocorrelogram", lag.max = 60, ylab = "", xlab = "", col = "blue", ci.col = "red")
pacf(coredata(Brent.return.abs), main = "Brent Partial Autocorrelogram", lag.max = 60, ylab = "", xlab = "", col = "blue", ci.col = "red")
name <-  "GNP"
URL <-  paste("http://research.stlouisfed.org/fred2/series/", name,
"/", "downloaddata/", name, ".csv", sep = "")
download <-  read.csv(URL)
hist(download[,2])
